module Sum
  use int.Int
  use real.Real
  use real.RealInfix
  
  let rec ghost function sum (f : int -> real) (a : int) (b : int) : 
    real
    requires { Int.( <= ) a b }
    variant { [@hyp_name:Variant] (Int.( - ) b a) } =
    if (a = b) then 0.0
    else ((f a) +. (sum f (a + 1) b))
end

module Init
  use int.Int
  use array.Array
  
  function init (n: int) (f: int -> real) : array real
  
  axiom init_spec:
    forall f, n.
      (n >= 0)
        ->
        (forall i. (0 <= i < n) -> (((init n f)[i]) = (f i)))
        /\
        ((length (init n f)) = n)
end

module VIPRCertificate
  use int.Int
  use int.Lex2
  use real.Real
  use real.RealInfix
  use real.FromInt
  use array.Array
  use set.Set
  use Sum
  
  predicate is_integer (x: real) = exists i : int. x = (from_int i)
  
  function n : int
  
  function m : int
  
  function d : int
  
  axiom H_con: (Int.( < ) 0 m) /\ (Int.( <= ) m d)
  
  axiom H_var: Int.( > ) n 0
  
  type sign = 
      | Leq
      | Geq
      | Eq
  
  function sign_to_int (s: sign) : int
  
  axiom sign_to_int_def:
    forall s : sign.
      ((s = Leq) -> ((sign_to_int s) = (- 1)))
        /\
        ((s = Eq) -> ((sign_to_int s) = 0))
        /\
        ((s = Geq) -> ((sign_to_int s) = 1))
  
  type constraint = { a : array real; b : real; s : sign }
  
  predicate is_constraint (con: constraint) = (Array.length (con.a)) = n
  
  function dot (a: array real) (b: array real) : real =
    sum (fun i-> (a[i]) *. (b[i])) 0 n
  
  predicate sat_constraint (sol: array real) (con: constraint) =
    match con.s with
    | Leq  -> (dot (con.a) sol) <= (con.b)
    | Geq  -> (dot (con.a) sol) >= (con.b)
    | Eq  -> (dot (con.a) sol) = (con.b)
    end
  
  type objective_sense = 
      | Min
      | Max
  
  type objective_function = { c : array real; sense : objective_sense }
  
  predicate is_objective_function (obj_func: objective_function) =
    (Array.length (obj_func.c))
    =
    n
  
  type lower_bound = 
      | LNone
      | LNum real
  
  type upper_bound = 
      | UNone
      | UNum real
  
  type interval = { lb : lower_bound; ub : upper_bound }
  
  type rtp_type = 
      | Infeasible
      | Interval interval
  
  type reason = 
      | Asm
      | Lin
      | Rnd
      | Uns
      | Sol
  
  type reason_data = 
      | D_none
      | D_lin_comb (array real)
      | D_uns (array int)
  
  predicate in_range (x: int) (ub: int) =
    (Int.( <= ) 0 x) /\ (Int.( < ) x ub)
  
  predicate valid_reason_data (r: reason) (rd: reason_data) =
    (((r = Asm) \/ (r = Sol)) /\ (rd = D_none))
      \/
      (((r = Lin) \/ (r = Rnd)) /\
         (exists arr. (rd = (D_lin_comb arr)) /\ ((Array.length arr) = d)))
      \/
      ((r = Uns) /\
         (exists arr.
            (rd = (D_uns arr))
              /\
              ((Array.length arr) = 4)
              /\
              (forall i : int. (in_range i 4) -> (in_range (arr[i]) d))))
  
  type derived_constraint = {
                           con : constraint;
                           rsn : reason;
                           data : reason_data;
                           a_set : set int
                           }
  
  predicate is_der_con (dc: derived_constraint) =
    (is_constraint (dc.con))
      /\
      (valid_reason_data (dc.rsn) (dc.data))
      /\
      (forall i : int.
         (mem i (dc.a_set)) -> ((Int.( <= ) m i) /\ (Int.( < ) i d)))
  
  lemma valid_reason_data_Asm: valid_reason_data Asm D_none
  
  lemma valid_reason_data_does_imply_data_none:
    forall rsn : reason, dat : reason_data.
      (valid_reason_data rsn dat) -> (rsn = Asm) -> (dat = D_none)
  
  type certificate = {
                    cINT : set int;
                    cOBJ : objective_function;
                    cCON : array constraint;
                    cRTP : rtp_type;
                    cSOL : set (array real);
                    cDER : array derived_constraint
                    }
  
  predicate is_asm_index (cert: certificate) (i: int) =
    (Int.( <= ) m i)
      /\
      (Int.( < ) i d)
      /\
      (let j = Int.( - ) i m in
       (in_range j (length (cert.cDER)))
         /\
         (let dc = (cert.cDER)[j] in
          (dc.rsn)
          =
          Asm))
  
  predicate is_cert (cert: certificate) =
    (forall i : int. (mem i (cert.cINT)) -> (in_range i n))
      /\
      (is_objective_function (cert.cOBJ))
      /\
      ((length (cert.cCON)) = m)
      /\
      (forall i : int. (in_range i m) -> (is_constraint ((cert.cCON)[i])))
      /\
      (forall sol : (array real). (mem sol (cert.cSOL)) -> ((length sol) = n))
      /\
      ((length (cert.cDER)) = (Int.( - ) d m))
      /\
      (forall idx : int.
         (in_range idx (length (cert.cDER)))
           ->
           (is_der_con ((cert.cDER)[idx])))
      /\
      (forall idx : int.
         (in_range idx (length (cert.cDER)))
           ->
           (forall i : int.
              (mem i (((cert.cDER)[idx]).a_set)) -> (is_asm_index cert i)))
end

module VIPRHelpers
  use VIPRCertificate
  use int.Int
  use int.Lex2
  use real.Real
  use real.RealInfix
  use real.FromInt
  use real.Truncate
  use array.Array
  use array.ArrayEq
  use set.Set
  use Sum
  use Init
  
  type generalized_sign = 
      | Sign sign
      | SNone
  
  type generalized_constraint = {
                               lhs : array real;
                               rhs : real;
                               sgn : generalized_sign
                               }
  
  function get_constraint (cert: certificate) (k: int) : constraint =
    if (Int.( < ) k m) then ((cert.cCON)[k])
    else (((cert.cDER)[Int.( - ) k m]).con)
  
  predicate is_absurdity (con: constraint) =
    (forall i : int. (in_range i n) -> (((con.a)[i]) = 0.0))
      /\
      (match con.s with
       | Geq  -> (con.b) > 0.0
       | Leq  -> (con.b) < 0.0
       | Eq  -> (con.b) <> 0.0
       end)
  
  predicate con_dom_con (c1: constraint) (c2: constraint) =
    (is_absurdity c1)
      \/
      ((forall j : int. (in_range j n) -> (((c1.a)[j]) = ((c2.a)[j]))) /\
         ((((c1.s) = Eq) /\ (((c2.s) = Geq) /\ ((c1.b) >= (c2.b)))) \/
            ((((c1.s) = Eq) /\ (((c2.s) = Eq) /\ ((c1.b) = (c2.b))))
               \/
               (((c1.s) = Eq) /\ (((c2.s) = Leq) /\ ((c1.b) <= (c2.b))))
               \/
               (((c1.s) = Geq) /\ (((c2.s) = Geq) /\ ((c1.b) >= (c2.b))))
               \/
               (((c1.s) = Leq) /\ (((c2.s) = Leq) /\ ((c1.b) <= (c2.b)))))))
  
  predicate gen_con_dom_con (c1: generalized_constraint) (c2: constraint) =
    match c1.sgn with
    | SNone  -> false
    | Sign sign -> con_dom_con { a = (c1.lhs) ; b = (c1.rhs) ; s = sign } c2
    end
  
  function get_lin_comb (cert: certificate) (weights: array real) : generalized_constraint =
    { lhs =
        (init
           n
           (fun j->
              sum
                (fun i-> (weights[i]) *. (((get_constraint cert i).a)[j]))
                0
                d)) ;
      rhs = (sum (fun i-> (weights[i]) *. ((get_constraint cert i).b)) 0 d) ;
      sgn =
        (let sgn_prod =
           fun i->
             (weights[i])
               *. (from_int (sign_to_int ((get_constraint cert i).s))) in
         let all_nonneg =
           (forall i : int.
              ((in_range i d) /\ ((weights[i]) <> 0.0))
                ->
                ((sgn_prod i) >= 0.0)) :
             bool in
         let some_pos =
           (exists i : int.
              (in_range i d) /\ ((weights[i]) <> 0.0) /\ ((sgn_prod i) > 0.0)) :
             bool in
         let all_zero =
           (forall i : int.
              ((in_range i d) /\ ((weights[i]) <> 0.0))
                ->
                ((sgn_prod i) = 0.0)) :
             bool in
         let all_nonpos =
           (forall i : int.
              ((in_range i d) /\ ((weights[i]) <> 0.0))
                ->
                ((sgn_prod i) <= 0.0)) :
             bool in
         let some_neg =
           (exists i : int.
              (in_range i d) /\ ((weights[i]) <> 0.0) /\ ((sgn_prod i) < 0.0)) :
             bool in
         if (all_nonneg /\ some_pos) then (Sign Geq)
         else
           (if all_zero then (Sign Eq)
            else (if (all_nonpos /\ some_neg) then (Sign Leq)
                  else SNone))) }
  
  predicate roundable (cert: certificate) (con: constraint) =
    ((con.s) <> Eq)
      /\
      (forall i.
         (in_range i n)
           ->
           (if (mem i (cert.cINT)) then (is_integer ((con.a)[i]))
            else (((con.a)[i]) = 0.0)))
  
  function rnd (cert: certificate) (con: constraint) : constraint =
    if (not (roundable cert con)) then con
    else
      (match con.s with
       | Geq  -> { a = (con.a) ; b = (from_int (ceil (con.b))) ; s = Geq }
       | Leq  -> { a = (con.a) ; b = (from_int (floor (con.b))) ; s = Leq }
       | Eq  -> con
       end)
  
  predicate rnd_con_dom_con (cert: certificate) (c1: constraint) (c2: constraint) =
    if (roundable cert c1) then (con_dom_con (rnd cert c1) c2)
    else false
  
  predicate rnd_gen_con_dom_con (cert: certificate) (c1: generalized_constraint) (c2: constraint) =
    match c1.sgn with
    | SNone  -> false
    | Sign sign ->
        rnd_con_dom_con cert { a = (c1.lhs) ; b = (c1.rhs) ; s = sign } c2
    end
  
  predicate is_disjunction (cert: certificate) (c1: constraint) (c2: constraint) =
    (forall k : int. (in_range k n) -> (((c1.a)[k]) = ((c2.a)[k])))
      /\
      (forall i.
         (in_range i n)
           ->
           (if (mem i (cert.cINT)) then (is_integer ((c1.a)[i]))
            else (((c1.a)[i]) = 0.0)))
      /\
      ((is_integer (c1.b)) /\ (is_integer (c2.b)))
      /\
      (match ((c1.s), (c2.s)) with
       | (Geq , Leq ) -> ((c1.b) - (c2.b)) = 1.0
       | (Leq , Geq ) -> ((c2.b) - (c1.b)) = 1.0
       | (_, _) -> false
       end)
  
  predicate is_asm_of (cert: certificate) (j: int) (i: int) =
    if ((in_range i d) /\ (not (in_range i m))) then
      (mem j (((cert.cDER)[Int.( - ) i m]).a_set))
    else false
end

module VIPRValidity
  use VIPRCertificate
  use VIPRHelpers
  use int.Int
  use int.Lex2
  use real.Real
  use real.RealInfix
  use real.FromInt
  use array.Array
  use set.Set
  
  predicate valid_FEAS (cert: certificate) =
    forall sol : (array real).
      (mem sol (cert.cSOL))
        ->
        (forall j : int. (mem j (cert.cINT)) -> (is_integer (sol[j])))
        /\
        (forall i : int.
           (in_range i m) -> (sat_constraint sol ((cert.cCON)[i])))
  
  predicate valid_SOL (cert: certificate) =
    match cert.cRTP with
    | Infeasible  -> is_empty (cert.cSOL)
    | Interval interval ->
        (valid_FEAS cert)
          /\
          (match interval.ub with
           | UNone  -> true
           | UNum upper ->
               ((((cert.cOBJ).sense) = Min) ->
                  (exists x : array real.
                     (mem x (cert.cSOL))
                       /\
                       (sat_constraint
                          x
                          { a = ((cert.cOBJ).c) ; b = upper ; s = Leq })))
           end)
          /\
          (match interval.lb with
           | LNone  -> true
           | LNum lower ->
               ((((cert.cOBJ).sense) = Max) ->
                  (exists x : array real.
                     (mem x (cert.cSOL))
                       /\
                       (sat_constraint
                          x
                          { a = ((cert.cOBJ).c) ; b = lower ; s = Geq })))
           end)
    end
  
  predicate val_ASM (cert: certificate) (k: int) =
    let k_total = Int.( + ) k m in
    let dc = (cert.cDER)[k] in
    (forall i : int. (mem i (dc.a_set)) -> (Int.( <= ) (Int.( - ) i m) k))
      /\
      (match ((dc.rsn), (dc.data)) with
       | (Asm , D_none ) -> (dc.a_set) = (add (Int.( + ) k m) empty)
       | (Lin , (D_lin_comb weights)) | (Rnd , (D_lin_comb weights)) ->
           ((forall j : int.
               (mem j (dc.a_set))
                 <->
                 (exists i : int.
                    ((weights[i]) <> 0.0)
                      /\
                      (Int.( <= ) m i)
                      /\
                      (Int.( < ) i k_total)
                      /\
                      (mem j (((cert.cDER)[Int.( - ) i m]).a_set)))) /\
              (forall i : int.
                 (((weights[i]) <> 0.0)
                    /\
                    (Int.( <= ) m i)
                    /\
                    (Int.( < ) i k_total))
                   ->
                   (forall j : int.
                      (mem j (((cert.cDER)[Int.( - ) i m]).a_set))
                        ->
                        (mem j (dc.a_set)))))
       | (Uns , (D_uns indices)) ->
           let i1 = indices[0] in
           let l1 = indices[1] in
           let i2 = indices[2] in
           let l2 = indices[3] in
           forall j : int.
             (is_asm_of cert j k_total)
               <->
               (((is_asm_of cert j i1) /\ (j <> l1)) \/
                  ((is_asm_of cert j i2) /\ (j <> l2)))
       | (Sol , D_none ) -> is_empty (dc.a_set)
       | (_, _) -> false
       end)
  
  predicate valid_DER_k (cert: certificate) (k: int) =
    let dc = (cert.cDER)[k] in
    let total_k = Int.( + ) k m in
    (val_ASM cert k)
      /\
      (match ((dc.rsn), (dc.data)) with
       | (Asm , D_none ) -> true
       | (Lin , (D_lin_comb weights)) ->
           (forall i : int.
              ((in_range i d) /\ ((weights[i]) <> 0.0))
                ->
                (Int.( < ) i total_k))
             /\
             (gen_con_dom_con (get_lin_comb cert weights) (dc.con))
       | (Rnd , (D_lin_comb weights)) ->
           (forall i : int.
              ((in_range i d) /\ ((weights[i]) <> 0.0))
                ->
                (Int.( < ) i total_k))
             /\
             (rnd_gen_con_dom_con cert (get_lin_comb cert weights) (dc.con))
       | (Uns , (D_uns indices)) ->
           let i1 = indices[0] in
           let l1 = indices[1] in
           let i2 = indices[2] in
           let l2 = indices[3] in
           (in_range i1 total_k)
             /\
             (in_range l1 total_k)
             /\
             (in_range i2 total_k)
             /\
             (in_range l2 total_k)
             /\
             (let ci1 = get_constraint cert i1 in
              let cl1 = get_constraint cert l1 in
              let ci2 = get_constraint cert i2 in
              let cl2 = get_constraint cert l2 in
              (con_dom_con ci1 (dc.con))
                /\
                (con_dom_con ci2 (dc.con))
                /\
                (is_disjunction cert cl1 cl2))
       | (Sol , D_none ) ->
           (((((cert.cOBJ).sense) = Min) ->
               (exists sol : array real.
                  (mem sol (cert.cSOL))
                    /\
                    (con_dom_con
                       { a = ((cert.cOBJ).c) ;
                         b = (dot ((cert.cOBJ).c) sol) ;
                         s = Leq }
                       (dc.con)))) /\
              ((((cert.cOBJ).sense) = Max) ->
                 (exists sol : array real.
                    (mem sol (cert.cSOL))
                      /\
                      (con_dom_con
                         { a = ((cert.cOBJ).c) ;
                           b = (dot ((cert.cOBJ).c) sol) ;
                           s = Geq }
                         (dc.con)))))
       | (_, _) -> false
       end)
  
  predicate valid_DER (cert: certificate) =
    (forall k : int. (in_range k (Int.( - ) d m)) -> (valid_DER_k cert k))
      /\
      (let d_index = Int.( - ) d 1 in
       let cd = get_constraint cert d_index in
       match ((cert.cRTP), ((cert.cOBJ).sense)) with
       | (Infeasible , _) ->
           (forall j : int. not (is_asm_of cert j d_index))
             /\
             (is_absurdity cd)
       | ((Interval interval), Min ) ->
           match interval.lb with
           | LNone  -> true
           | LNum lower ->
               (con_dom_con cd { a = ((cert.cOBJ).c) ; b = lower ; s = Geq })
                 /\
                 (forall j : int. not (is_asm_of cert j d_index))
           end
       | ((Interval interval), Max ) ->
           match interval.ub with
           | UNone  -> true
           | UNum upper ->
               (con_dom_con cd { a = ((cert.cOBJ).c) ; b = upper ; s = Leq })
                 /\
                 (forall j : int. not (is_asm_of cert j d_index))
           end
       end)
  
  predicate valid (cert: certificate) = (valid_SOL cert) /\ (valid_DER cert)
end

module VIPRPredicate
  use VIPRCertificate
  use VIPRHelpers
  use int.Int
  use int.Lex2
  use real.Real
  use real.RealInfix
  use real.FromInt
  use real.Truncate
  use array.Array
  use set.Set
  use Sum
  use Init
  
  predicate p (cert: certificate) =
    match (cert.cOBJ).sense with
    | Min  -> true
    | Max  -> false
    end
  
  predicate r (cert: certificate) =
    match cert.cRTP with
    | Infeasible  -> false
    | Interval _ -> true
    end
  
  predicate pub (cert: certificate) =
    exists i : interval.
      ((cert.cRTP) = (Interval i)) /\ (exists r : real. (i.ub) = (UNum r))
  
  function u (cert: certificate) : real =
    match cert.cRTP with
    | Interval i -> match i.ub with
                    | UNone  -> 0.0
                    | UNum x -> x
                    end
    | Infeasible  -> 0.0
    end
  
  predicate plb (cert: certificate) =
    exists i : interval.
      ((cert.cRTP) = (Interval i)) /\ (exists r : real. (i.lb) = (LNum r))
  
  function l (cert: certificate) : real =
    match cert.cRTP with
    | Interval i -> match i.lb with
                    | LNone  -> 0.0
                    | LNum x -> x
                    end
    | Infeasible  -> 0.0
    end
  
  predicate phi_FEAS (cert: certificate) =
    forall sol : (array real).
      (mem sol (cert.cSOL))
        ->
        (forall j : int. (mem j (cert.cINT)) -> (is_integer (sol[j])))
        /\
        (forall i : int.
           (in_range i m)
             ->
             ((Int.( >= ) (sign_to_int (((cert.cCON)[i]).s)) 0) ->
                ((dot (((cert.cCON)[i]).a) sol) >= (((cert.cCON)[i]).b)))
             /\
             ((Int.( <= ) (sign_to_int (((cert.cCON)[i]).s)) 0) ->
                ((dot (((cert.cCON)[i]).a) sol) <= (((cert.cCON)[i]).b))))
  
  predicate phi_SOL (cert: certificate) =
    if (not (r cert)) then (is_empty (cert.cSOL))
    else
      ((phi_FEAS cert) /\
         (if (p cert) then
            ((pub cert) ->
               (exists sol : array real.
                  (mem sol (cert.cSOL))
                    /\
                    (sat_constraint
                       sol
                       { a = ((cert.cOBJ).c) ; b = (u cert) ; s = Leq })))
          else
            ((plb cert) ->
               (exists sol : array real.
                  (mem sol (cert.cSOL))
                    /\
                    (sat_constraint
                       sol
                       { a = ((cert.cOBJ).c) ; b = (l cert) ; s = Geq })))))
  
  predicate phi_ASM (cert: certificate) (k: int) =
    let k_total = Int.( + ) k m in
    let dc = (cert.cDER)[k] in
    (forall j.
       (((is_asm_index cert j) /\ (Int.( > ) j k_total)) ->
          (not (is_asm_of cert j k_total))))
      /\
      (match ((dc.rsn), (dc.data)) with
       | (Asm , D_none ) ->
           (is_asm_of cert k_total k_total)
             /\
             (forall j : int.
                (((is_asm_index cert j) /\ (Int.( < ) j k_total)) ->
                   (not (is_asm_of cert j k_total))))
       | (Lin , (D_lin_comb weights)) | (Rnd , (D_lin_comb weights)) ->
           forall j : int.
             (((is_asm_index cert j) /\ (Int.( < ) j k_total)) ->
                ((is_asm_of cert j k_total)
                   = (exists i : int.
                        ((((weights[i]) <> 0.0) /\
                            ((Int.( <= ) j i) /\ (Int.( < ) i k_total))) /\
                           (is_asm_of cert j i)))))
       | (Uns , (D_uns indices)) ->
           let i1 = indices[0] in
           let l1 = indices[1] in
           let i2 = indices[2] in
           let l2 = indices[3] in
           forall j : int.
             (((is_asm_index cert j) /\ (Int.( < ) j k_total)) ->
                ((is_asm_of cert j k_total)
                   = (((is_asm_of cert j i1) /\ (j <> l1)) \/
                        ((is_asm_of cert j i2) /\ (j <> l2)))))
       | (Sol , D_none ) ->
           forall j : int.
             (((is_asm_index cert j) /\ (Int.( < ) j k_total)) ->
                (not (is_asm_of cert j k_total)))
       | (_, _) -> false
       end)
  
  predicate phi_DOM_expanded (a1: array real) (a2: array real) (b1: real) (b2: real) (eq1: bool) (eq2: bool) (geq1: bool) (geq2: bool) (leq1: bool) (leq2: bool) =
    ((forall j : int. (in_range j n) -> ((a1[j]) = 0.0)) /\
       (if eq1 then (b1 <> 0.0)
        else
          (if geq1 then (b1 > 0.0)
           else (if leq1 then (b1 < 0.0)
                 else false))))
      \/
      ((forall j : int. (in_range j n) -> ((a1[j]) = (a2[j]))) /\
         (if eq2 then (eq1 /\ (b1 = b2))
          else
            (if geq2 then (geq1 /\ (b1 >= b2))
             else (if leq2 then (leq1 /\ (b1 <= b2))
                   else false))))
  
  predicate phi_DOM_constr (c1: constraint) (c2: constraint) =
    phi_DOM_expanded
      (c1.a)
      (c2.a)
      (c1.b)
      (c2.b)
      (Int.( = ) (sign_to_int (c1.s)) 0)
      (Int.( = ) (sign_to_int (c2.s)) 0)
      (Int.( >= ) (sign_to_int (c1.s)) 0)
      (Int.( >= ) (sign_to_int (c2.s)) 0)
      (Int.( <= ) (sign_to_int (c1.s)) 0)
      (Int.( <= ) (sign_to_int (c2.s)) 0)
  
  predicate phi_RND (cert: certificate) (a: array real) (eq: bool) =
    (forall j : int. (mem j (cert.cINT)) -> (is_integer (a[j])))
      /\
      (forall j : int.
         ((in_range j n) /\ (not (mem j (cert.cINT)))) -> ((a[j]) = 0.0))
      /\
      (not eq)
  
  predicate phi_DIS (cert: certificate) (ci: constraint) (cj: constraint) =
    (forall k : int. (in_range k n) -> (((ci.a)[k]) = ((cj.a)[k])))
      /\
      (forall k : int. (mem k (cert.cINT)) -> (is_integer ((ci.a)[k])))
      /\
      (forall k : int.
         ((in_range k n) /\ (not (mem k (cert.cINT)))) -> (((ci.a)[k]) = 0.0))
      /\
      (is_integer (ci.b))
      /\
      (is_integer (cj.b))
      /\
      (((ci.s) <> Eq) /\ (((cj.s) <> Eq) /\ ((ci.s) <> (cj.s))))
      /\
      (if ((ci.s) = Geq) then ((ci.b) = ((cj.b) + 1.0))
       else ((ci.b) = ((cj.b) - 1.0)))
  
  predicate phi_DER_k (cert: certificate) (k: int) =
    let k_total = Int.( + ) k m in
    let dc = (cert.cDER)[k] in
    (phi_ASM cert k)
      /\
      (match ((dc.rsn), (dc.data)) with
       | (Asm , D_none ) -> true
       | (Lin , (D_lin_comb weights)) ->
           let sgn_prod =
             fun i->
               (weights[i])
                 *. (from_int (sign_to_int ((get_constraint cert i).s))) in
           let all_nonneg =
             (forall i : int.
                ((in_range i d) /\ ((weights[i]) <> 0.0))
                  ->
                  ((sgn_prod i) >=. 0.0)) :
               bool in
           let all_zero =
             (forall i : int.
                ((in_range i d) /\ ((weights[i]) <> 0.0))
                  ->
                  ((sgn_prod i) = 0.0)) :
               bool in
           let all_nonpos =
             (forall i : int.
                ((in_range i d) /\ ((weights[i]) <> 0.0))
                  ->
                  ((sgn_prod i) <=. 0.0)) :
               bool in
           let gen_con = (get_lin_comb cert weights) : generalized_constraint in
           (forall i : int.
              ((in_range i d) /\ ((weights[i]) <> 0.0))
                ->
                (Int.( < ) i k_total))
             /\
             (phi_DOM_expanded
                (gen_con.lhs)
                ((dc.con).a)
                (gen_con.rhs)
                ((dc.con).b)
                all_zero
                (((dc.con).s) = Eq)
                all_nonneg
                (((dc.con).s) = Geq)
                all_nonpos
                (((dc.con).s) = Leq))
       | (Rnd , (D_lin_comb weights)) ->
           let sgn_prod =
             fun i->
               (weights[i])
                 *. (from_int (sign_to_int ((get_constraint cert i).s))) in
           let all_nonneg =
             (forall i : int.
                ((in_range i d) /\ ((weights[i]) <> 0.0))
                  ->
                  ((sgn_prod i) >=. 0.0)) :
               bool in
           let all_zero =
             (forall i : int.
                ((in_range i d) /\ ((weights[i]) <> 0.0))
                  ->
                  ((sgn_prod i) = 0.0)) :
               bool in
           let all_nonpos =
             (forall i : int.
                ((in_range i d) /\ ((weights[i]) <> 0.0))
                  ->
                  ((sgn_prod i) <=. 0.0)) :
               bool in
           let gen_con = (get_lin_comb cert weights) : generalized_constraint in
           (forall i : int.
              ((in_range i d) /\ ((weights[i]) <> 0.0))
                ->
                (Int.( < ) i k_total))
             /\
             (phi_RND cert (gen_con.lhs) all_zero)
             /\
             (((forall j : int. (in_range j n) -> (((gen_con.lhs)[j]) = 0.0)) /\
                 (if all_nonneg then ((gen_con.rhs) >. 0.0)
                  else (if all_nonpos then ((gen_con.rhs) <. 0.0)
                        else false))) \/
                ((forall j : int.
                    (in_range j n)
                      ->
                      (((gen_con.lhs)[j]) = (((dc.con).a)[j]))) /\
                   (if (((dc.con).s) = Eq) then false
                    else
                      (if (((dc.con).s) = Geq) then
                         (all_nonneg /\
                            ((from_int (ceil (gen_con.rhs)))
                             >=.
                             ((dc.con).b)))
                       else
                         (all_nonpos /\
                            ((from_int (floor (gen_con.rhs)))
                             <=.
                             ((dc.con).b)))))))
       | (Uns , (D_uns indices)) ->
           let i1 = indices[0] in
           let l1 = indices[1] in
           let i2 = indices[2] in
           let l2 = indices[3] in
           (Int.( > ) k_total i1)
             /\
             (Int.( > ) k_total i2)
             /\
             (Int.( > ) k_total l1)
             /\
             (Int.( > ) k_total l2)
             /\
             (let ci1 = get_constraint cert i1 in
              let cl1 = get_constraint cert l1 in
              let ci2 = get_constraint cert i2 in
              let cl2 = get_constraint cert l2 in
              (phi_DOM_constr ci1 (dc.con))
                /\
                (phi_DOM_constr ci2 (dc.con))
                /\
                (phi_DIS cert cl1 cl2))
       | (Sol , D_none ) ->
           if (p cert) then
             (exists sol : array real.
                (mem sol (cert.cSOL))
                  /\
                  (phi_DOM_constr
                     { a = ((cert.cOBJ).c) ;
                       b = (dot ((cert.cOBJ).c) sol) ;
                       s = Leq }
                     (dc.con)))
           else
             (exists sol : array real.
                (mem sol (cert.cSOL))
                  /\
                  (phi_DOM_constr
                     { a = ((cert.cOBJ).c) ;
                       b = (dot ((cert.cOBJ).c) sol) ;
                       s = Geq }
                     (dc.con)))
       | (_, _) -> false
       end)
  
  predicate phi_DER (cert: certificate) =
    let d_index = Int.( - ) d 1 in
    let cd = get_constraint cert d_index in
    (forall k : int.
       ((Int.( <= ) 0 k) /\ (Int.( < ) k (Int.( - ) d m)))
         ->
         (phi_DER_k cert k))
      /\
      (if (not (r cert)) then
         ((phi_DOM_constr cd { a = (make n 0.0) ; b = 1.0 ; s = Geq }) /\
            (forall j : int.
               (is_asm_index cert j) -> (not (is_asm_of cert j d_index))))
       else
         ((((p cert) /\ (plb cert)) ->
             ((phi_DOM_constr
                 cd
                 { a = ((cert.cOBJ).c) ; b = (l cert) ; s = Geq }) /\
                (forall j : int.
                   (is_asm_index cert j) -> (not (is_asm_of cert j d_index))))) /\
            (((not (p cert)) /\ (pub cert)) ->
               ((phi_DOM_constr
                   cd
                   { a = ((cert.cOBJ).c) ; b = (u cert) ; s = Leq }) /\
                  (forall j : int.
                     (is_asm_index cert j)
                       ->
                       (not (is_asm_of cert j d_index)))))))
  
  predicate phi (cert: certificate) = (phi_SOL cert) /\ (phi_DER cert)
end

module Main
  use VIPRCertificate
  use VIPRHelpers
  use VIPRValidity
  use VIPRPredicate
  use array.Array
  use set.Set
  use array.ArrayEq
  use real.Real
  use real.RealInfix
  use real.Abs
  use real.FromInt
  use real.Truncate
  use int.Lex2
  use Sum
  use Init
  use int.Int
  
  lemma LemmaFEAS:
    forall cert : certificate.
      (is_cert cert) -> ((valid_FEAS cert) <-> (phi_FEAS cert))
  
  
  lemma LemmaSOL:
    forall cert : certificate.
      (is_cert cert) -> ((valid_SOL cert) <-> (phi_SOL cert))
 
  
  lemma LemmaASM:
    forall cert : certificate, k : int.
      (is_cert cert)
        ->
        (0 <= k < (d - m))
        ->
        ((((cert.cDER)[k]).rsn) = Asm)
        ->
        (valid_DER_k cert k)
        <->
        (phi_DER_k cert k)
  
  lemma LemmaDOM:
    forall c1 : constraint, c2 : constraint.
      ((is_constraint c1) /\ (is_constraint c2))
        ->
        ((con_dom_con c1 c2) <-> (phi_DOM_constr c1 c2))
  
  lemma LemmaLin:
    forall cert : certificate, k : int.
      (is_cert cert)
        ->
        (0 <= k < (d - m))
        ->
        ((((cert.cDER)[k]).rsn) = Lin)
        ->
        (forall j : int. (0 <= j < k) -> (valid_DER_k cert j))
        ->
        (phi_DER_k cert k)
        <->
        (valid_DER_k cert k)
  
  lemma LemmaRND_Predicate:
    forall cert : certificate, con : constraint.
      (is_cert cert)
        ->
        (phi_RND cert (con.a) ((con.s) = Eq))
        <->
        (roundable cert con)
  
 
  lemma LemmaRND:
    forall cert : certificate, k : int.
      (is_cert cert)
        ->
        (0 <= k < (d - m))
        ->
        ((((cert.cDER)[k]).rsn) = Rnd)
        ->
        (forall j : int. (0 <= j < k) -> (valid_DER_k cert j))
        ->
        (valid_DER_k cert k)
        <->
        (phi_DER_k cert k)

  lemma LemmaDIS:
    forall cert : certificate, c1 : constraint, c2 : constraint.
      (is_cert cert)
        ->
        ((is_disjunction cert c1 c2) <-> (phi_DIS cert c1 c2))
  
  
  lemma LemmaUNS:
    forall cert : certificate, k : int.
      (is_cert cert)
        ->
        (0 <= k < (d - m))
        ->
        ((((cert.cDER)[k]).rsn) = Uns)
        ->
        (forall j : int. (0 <= j < k) -> (valid_DER_k cert j))
        ->
        (valid_DER_k cert k)
        <->
        (phi_DER_k cert k)
  
  lemma LemmaSOL_valid:
    forall cert : certificate, k : int.
      (is_cert cert)
        ->
        (0 <= k < (d - m))
        ->
        ((((cert.cDER)[k]).rsn) = Sol)
        ->
        (forall j : int. (0 <= j < k) -> (valid_DER_k cert j))
        ->
        (valid_DER_k cert k)
        <->
        (phi_DER_k cert k)
  
  lemma LemmaDER_k:
    forall cert : certificate, k : int.
      (is_cert cert)
        ->
        (0 <= k < (d - m))
        ->
        (forall j : int. (0 <= j < k) -> (valid_DER_k cert j))
        ->
        (valid_DER_k cert k)
        <->
        (phi_DER_k cert k)
   
  lemma LemmaDER:
    forall cert : certificate.
      (is_cert cert) -> ((valid_DER cert) <-> (phi_DER cert))
  
  
  goal MainTheorem:
    forall cert : certificate.
      (is_cert cert) -> ((valid cert) <-> (phi cert))
end