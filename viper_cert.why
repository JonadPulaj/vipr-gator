module Sum
  use int.Int
  use real.Real
  use real.RealInfix

  let rec ghost function sum (f: int -> real) (a b: int) : real
    requires { Int.(<=) a b }
    variant { Int.(-) b a }
  = if a = b then 0.0 else f a +. sum f (a + 1) b

end


theory Init

  use  int.Int
  use  array.Array

  function init (n: int) (f: int -> real) : array real

  axiom init_spec:
    forall f n. n >= 0 ->
      (forall i. 0 <= i < n -> (init n f)[i] = f i) /\
      length (init n f) = n

end

theory VIPRCertificate

  use int.Int
  use int.Lex2
  use real.Real
  use real.RealInfix
  use real.FromInt
  use array.Array
  use set.Set
  use Sum
  
  predicate is_integer (x: real) =
    exists i: int. x = from_int i

  (* ---------- Type and constants ---------- *)

  (* Dimensions of the certificate *)
  constant n : int   (* number of variables *)
  constant m : int   (* number of original constraints *)
  constant d : int   (* total number of constraints *)
  
  (* Dimension assumptions *)
  axiom H_con : Int.(<) 0 m /\ Int.(<=) m d
  axiom H_var : Int.(>) n 0
  
  (* Basic types *)
  type sign =
    | Leq
    | Geq
    | Eq
  
  function sign_to_int (s: sign) : int

  (* Def. 1 in paper *)
  axiom sign_to_int_def:
  forall s: sign.
    (s = Leq -> sign_to_int s = -1) /\
    (s = Eq  -> sign_to_int s =  0) /\
    (s = Geq -> sign_to_int s =  1)
    
  type constraint = {
    a : array real;
    b : real;
    s : sign
    }
  
  predicate is_constraint (con: constraint) = Array.length con.a = n
  
  function dot (a b: array real) : real =
    sum (fun i -> a[i] *. b[i]) 0 n
  
  predicate sat_constraint (sol: array real) (con: constraint) =
    match con.s with
    | Leq -> dot con.a sol <= con.b
    | Geq -> dot con.a sol >= con.b
    | Eq -> dot con.a sol = con.b
    end
  
  type objective_sense = 
    | Min
    | Max
   
  type objective_function = {
    c : array real;
    sense : objective_sense;
    }
  
  predicate is_objective_function (obj_func: objective_function) = Array.length obj_func.c = n
  
  type lower_bound =
    | LNone
    | LNum real
  
  type upper_bound =
    | UNone
    | UNum real
  
  type interval = {
    lb: lower_bound;
    ub: upper_bound
    }
    
  type rtp_type =
    | Infeasible
    | Interval interval
  
  
  type reason =
    | Asm
    | Lin
    | Rnd
    | Uns
    | Sol
  
  type reason_data =
    | D_none                      (* for Asm and Sol *)
    | D_lin_comb (array real)      (* for Lin and Rnd: dense array of length d *)
    | D_uns (array int)            (* for Uns: array of 4 indices in [0, d) *)
    
    
  predicate in_range (x:int) (ub:int) =
    Int. (<=) 0 x /\  Int. (<) x ub   
   
  predicate valid_reason_data (r: reason) (rd: reason_data) =
    ((r = Asm \/ r = Sol) /\ rd = D_none) \/
    ((r = Lin \/ r = Rnd) /\ (exists arr. rd = D_lin_comb arr /\ Array.length arr = d))
    \/ (r = Uns /\ (exists arr. rd = D_uns arr /\ Array.length arr = 4 
    /\ (forall i:int. in_range i 4 -> in_range arr[i] d ))) 
  
  
  type derived_constraint = {
    con: constraint;
    rsn: reason;
    data: reason_data;
    a_set: set int; (*assumption set*)
    }
  
  predicate is_der_con (dc: derived_constraint) =
    is_constraint dc.con /\ valid_reason_data dc.rsn dc.data /\
    forall i: int. mem i dc.a_set -> (Int.(<=) m i /\ Int.(<) i d) 
    
    
  lemma valid_reason_data_Asm: 
    valid_reason_data Asm D_none
  
  lemma valid_reason_data_does_imply_data_none:
  forall rsn: reason, dat: reason_data.
    valid_reason_data rsn dat -> rsn = Asm -> dat = D_none
    
   (*helper can be ignored*) 
  function index_from_der_index (der_i: int) : int = Int.(+) der_i m 
  
  type certificate = {
    cINT: set int;
    cOBJ: objective_function;
    cCON: array constraint;
    cRTP: rtp_type;
    cSOL: set (array real); (* check that each array has length n below *)
    cDER: array derived_constraint;
    }
  
  predicate is_asm_index (cert: certificate) (i: int) =
    Int.(<=) m i /\ Int.(<) i d /\
    let j = Int.(-) i m in
    in_range j (length cert.cDER) /\
    let dc = cert.cDER[j] in
    dc.rsn = Asm
 
  (* check all dimensions and all other requirements *) 
  predicate is_cert (cert: certificate) =
    (forall i: int. mem i cert.cINT -> in_range i n) /\
    (is_objective_function cert.cOBJ) /\
    (length cert.cCON = m) /\ (forall i: int. in_range i m -> is_constraint cert.cCON[i]) /\
    (forall sol: (array real). mem sol cert.cSOL -> length sol = n) /\ 
    (* derived constraint predicates *)
    (length cert.cDER = Int.(-) d m) /\ (* length of DER is d-m *)
    (forall idx: int. in_range idx (length cert.cDER) -> is_der_con cert.cDER[idx]) /\ (* each one is a derived constraint *)
    (forall idx: int. in_range idx (length cert.cDER) -> 
      forall i: int. mem i cert.cDER[idx].a_set -> is_asm_index cert i /\ Int.(<=) (Int.(-) i m) idx) (* all assumptions of each one are assumptions and have smaller index *)
      
      
   (*helper can be ignored*)  
   predicate test_lt (cert: certificate) = 
     forall i: int. in_range i m -> is_constraint cert.cCON[i]
     


end

theory VIPRHelpers
  
  use VIPRCertificate
  use int.Int
  use int.Lex2
  use real.Real
  use real.RealInfix
  use real.FromInt
  use real.Truncate
  use array.Array
  use array.ArrayEq
  use set.Set
  use Sum
  use Init
  
  (* Defining generalied versions of signs and constraints for linear combination constraints *)
  type generalized_sign =
    | Sign sign
    | SNone
  type generalized_constraint = {
    lhs: array real;
    rhs: real;
    sgn: generalized_sign
    }
  function get_constraint (cert: certificate) (k: int) : constraint =  
    if Int.(<) k m then cert.cCON[k] else cert.cDER[Int.(-) k m].con 

   (* predicate for Def. 2 in paper *)
  predicate is_absurdity (con: constraint) =
    (forall i: int. in_range i n -> con.a[i] = 0.0) /\
    match con.s with
    | Geq ->  con.b > 0.0
    | Leq ->  con.b < 0.0
    | Eq -> con.b <> 0.0
    end
    
    
  predicate con_dom_con (c1: constraint) (c2: constraint) = 
    is_absurdity c1 \/
     ( 
     (forall j: int. in_range j n -> c1.a[j] = c2.a[j]) /\
     ((c1.s = Eq /\ c2.s = Geq /\ c1.b >= c2.b) \/
     (c1.s = Eq /\ c2.s = Eq  /\ c1.b = c2.b) \/
     (c1.s = Eq /\ c2.s = Leq /\ c1.b <= c2.b) \/
     (c1.s = Geq /\ c2.s = Geq /\ c1.b >= c2.b) \/
     (c1.s = Leq /\ c2.s = Leq /\ c1.b <= c2.b))
     )
  
    
  predicate gen_con_dom_con (c1: generalized_constraint) (c2: constraint) =
    match c1.sgn with
    | SNone -> false
    | Sign sign -> con_dom_con { a = c1.lhs; b = c1.rhs; s = sign } c2
    end
  
  (* helper can be ignored *)
  predicate is_gen_con_test (gc: generalized_constraint) = Array.length gc.lhs = n
              
  
  function get_lin_comb (*Below: length weights = d *)
    (cert: certificate) (weights: array real) : generalized_constraint =
    {
      lhs = init n (fun j -> (sum (fun i -> weights[i] *. (get_constraint cert i).a[j]) 0 d));
      rhs = sum (fun i -> weights[i] *. (get_constraint cert i).b) 0 d;
      sgn =
        let sgn_prod =
          fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s))
        in
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >= 0.0 in
        let some_pos   : bool = exists i: int. in_range i d /\ sgn_prod i > 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <= 0.0 in
        let some_neg   : bool = exists i: int. in_range i d /\ sgn_prod i < 0.0 in
          if all_nonneg /\ some_pos then Sign Geq
          else if all_zero then Sign Eq
          else if all_nonpos /\ some_neg then Sign Leq
          else SNone
    }
  
 
  (* Rnd versions of above *)
  predicate roundable (cert: certificate) (con: constraint) =
    con.s <> Eq /\
    forall i. in_range i n -> 
      if mem i cert.cINT then is_integer con.a[i] else con.a[i] = 0.0 
  
  function rnd (cert: certificate) (con: constraint) : constraint = 
    if not roundable cert con then con else
      match con.s with
      | Geq -> { a = con.a; b = (from_int (ceil con.b)); s = Geq }
      | Leq -> { a = con.a; b = (from_int (floor con.b)); s = Leq }
      | Eq -> con 
      end
  
  predicate rnd_con_dom_con (cert: certificate) (c1: constraint) (c2: constraint) =
    if roundable cert c1 then con_dom_con (rnd cert c1) c2 else false
  
  predicate rnd_gen_con_dom_con (cert: certificate) (c1: generalized_constraint) (c2: constraint) =
    match c1.sgn with
    | SNone -> false
    | Sign sign -> rnd_con_dom_con cert { a = c1.lhs; b = c1.rhs; s = sign } c2
    end

  (* predicate for Def. 3 in our paper *)
  predicate is_disjunction (cert: certificate) (c1: constraint) (c2: constraint) =
    (forall k: int. in_range k n -> c1.a[k] = c2.a[k]) /\ (forall i. in_range i n -> 
    if mem i cert.cINT then is_integer c1.a[i] else c1.a[i] = 0.0) /\
    (is_integer c1.b /\ is_integer c2.b) /\  
      match c1.s, c2.s with
      | Geq, Leq -> c1.b - c2.b = 1.0
      | Leq, Geq -> c2.b - c1.b = 1.0
      | _, _ -> false
      end
  
  predicate is_asm_of (cert: certificate) (j i: int) = (* is j in A(C_i) *)
    if in_range i d /\ not (in_range i m) then mem j cert.cDER[Int.(-) i m].a_set else false 
  
end

theory VIPRValidity

  use VIPRCertificate
  use VIPRHelpers
  use int.Int
  use int.Lex2
  use real.Real
  use real.RealInfix
  use real.FromInt
  use array.Array
  use set.Set
  
  predicate valid_FEAS (cert: certificate) = 
    forall sol: (array real). mem sol cert.cSOL -> 
      (forall j: int. mem j cert.cINT -> is_integer sol[j]) /\
      (forall i: int. in_range i m -> sat_constraint sol cert.cCON[i])
  
  predicate valid_SOL (cert: certificate) = 
    match cert.cRTP with
    | Infeasible -> is_empty cert.cSOL
    | Interval interval -> valid_FEAS cert /\
      match interval.ub with
      | UNone -> true
      | UNum upper -> (cert.cOBJ.sense = Min -> 
        exists x: array real. mem x cert.cSOL /\ sat_constraint x { a = cert.cOBJ.c; b = upper; s = Leq })
      end /\
      match interval.lb with
      | LNone -> true
      | LNum lower -> (cert.cOBJ.sense = Max -> 
        exists x: array real. mem x cert.cSOL /\ sat_constraint x { a = cert.cOBJ.c; b = lower; s = Geq })
      end
    end
  
    
  (* all validity assumptions here *)
  predicate val_ASM (cert: certificate) (k: int) =
    let k_total = Int.(+) k m in
    let dc = cert.cDER[k] in
    match dc.rsn, dc.data with
    | Asm, D_none -> dc.a_set = add (Int.(+) k m) empty
    
    | Lin, D_lin_comb weights | Rnd, D_lin_comb weights ->  ( (forall j:int. mem j dc.a_set <-> exists i:int.
         weights[i] <> 0.0 /\ Int.(<=) m i /\ Int.(<) i k_total /\ mem j cert.cDER[Int.(-) i m].a_set) /\
       (forall i:int. weights[i] <> 0.0 /\ Int.(<=) m i /\ Int.(<) i k_total ->
        forall j:int. mem j cert.cDER[Int.(-) i m].a_set -> mem j dc.a_set) )   (*asumption set of derived constraints is exactly the union of inherited assumptions*)
        
    | Uns, D_uns indices -> 
       let i1 = indices[0] in
        let l1 = indices[1] in
        let i2 = indices[2] in
        let l2 = indices[3] in
       forall j: int.
          is_asm_of cert j k_total <-> (
            (is_asm_of cert j i1 /\ j <> l1) \/
            (is_asm_of cert j i2 /\ j <> l2)
          )
    | Sol, D_none -> is_empty dc.a_set
    | _, _ -> false
    end  
    
   predicate valid_DER_k (cert: certificate) (k: int) =
    let dc = cert.cDER[k] in
    let total_k = Int.(+) k m in
    val_ASM cert k /\
    match dc.rsn, dc.data with
    | Asm, D_none -> true
    | Lin, D_lin_comb weights -> 
         (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        (gen_con_dom_con (get_lin_comb cert weights) dc.con)
        
     | Rnd, D_lin_comb weights ->        
        (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        (rnd_gen_con_dom_con cert (get_lin_comb cert weights) dc.con) 
        
    | Uns, D_uns indices -> 
        let i1 = indices[0] in
        let l1 = indices[1] in
        let i2 = indices[2] in
        let l2 = indices[3] in
        in_range i1 total_k /\ in_range l1 total_k /\ in_range i2 total_k /\ in_range l2 total_k /\
        let ci1 = get_constraint cert i1 in
        let cl1 = get_constraint cert l1 in
        let ci2 = get_constraint cert i2 in
        let cl2 = get_constraint cert l2 in
        con_dom_con ci1 dc.con /\
        con_dom_con ci2 dc.con /\
        is_disjunction cert cl1 cl2 
        
    | Sol, D_none -> 
         ((cert.cOBJ.sense = Min -> exists sol: array real. mem sol cert.cSOL /\
         con_dom_con { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Leq } dc.con) /\ (cert.cOBJ.sense = Max ->
         exists sol: array real. mem sol cert.cSOL /\
         con_dom_con { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Geq } dc.con))
    
    | _, _ -> false
    end 
  
  predicate valid_DER (cert: certificate) = 
    (forall k: int. in_range k (Int.(-) d m) -> valid_DER_k cert k) /\
    let d_index = Int.(-) d 1 in
    let cd = get_constraint cert d_index
    in
    match cert.cRTP, cert.cOBJ.sense with
    | Infeasible, _ -> (forall j: int. not is_asm_of cert j d_index) /\ is_absurdity cd
    | Interval interval, Min -> 
      match interval.lb with
      | LNone -> true
      | LNum lower -> con_dom_con cd { a = cert.cOBJ.c; b = lower; s = Geq } /\
         forall j: int. not is_asm_of cert j d_index
      end
    | Interval interval, Max -> 
      match interval.ub with
      | UNone -> true
      | UNum upper -> con_dom_con cd { a = cert.cOBJ.c; b = upper; s = Leq } /\
         forall j: int. not is_asm_of cert j d_index
      end
    end
  
  predicate valid (cert: certificate) = valid_SOL cert /\ valid_DER cert

end


theory VIPRPredicate

  use VIPRCertificate
  use VIPRHelpers
  use int.Int
  use int.Lex2
  use real.Real
  use real.RealInfix
  use real.FromInt
  use real.Truncate
  use array.Array
  use set.Set
  use Sum
  use Init
    
  predicate p (cert: certificate) = 
    match cert.cOBJ.sense with
    | Min -> true
    | Max -> false
    end
  
  predicate r (cert: certificate) = 
    match cert.cRTP with
    | Infeasible -> false
    | Interval _ -> true
    end
  
  predicate pub (cert: certificate) =
  (exists i: interval. cert.cRTP = Interval i /\ 
    (exists r: real. i.ub = UNum r))
  
  function u (cert: certificate) : real =
    match cert.cRTP with
    | Interval i ->
      match i.ub with
      | UNone -> 0.0
      | UNum x -> x
      end
    | Infeasible -> 0.0
    end
      
  predicate plb (cert: certificate) =
  (exists i: interval. cert.cRTP = Interval i /\
    (exists r: real. i.lb = LNum r))
  
  function l (cert: certificate) : real =
    match cert.cRTP with
    | Interval i ->
      match i.lb with
      | LNone -> 0.0
      | LNum x -> x
      end
    | Infeasible -> 0.0
    end
  
  predicate phi_FEAS (cert: certificate) = 
    forall sol: (array real). mem sol cert.cSOL -> 
      (forall j: int. mem j cert.cINT -> is_integer sol[j]) /\
      (forall i: int. in_range i m -> 
        (Int.(>=) (sign_to_int cert.cCON[i].s) 0 -> dot cert.cCON[i].a sol >= cert.cCON[i].b) /\
        (Int.(<=) (sign_to_int cert.cCON[i].s) 0 -> dot cert.cCON[i].a sol <= cert.cCON[i].b)
      )

predicate phi_SOL (cert: certificate) = 
    if not r cert then is_empty cert.cSOL else
    (phi_FEAS cert /\ (if p cert then
    (pub cert -> 
      exists sol: array real. mem sol cert.cSOL /\ sat_constraint sol { a = cert.cOBJ.c; b = u cert; s = Leq }
    ) else
    (plb cert ->
      exists sol: array real. mem sol cert.cSOL /\ sat_constraint sol { a = cert.cOBJ.c; b = l cert; s = Geq }
    )))

 predicate phi_ASM (cert: certificate) (k: int) =
    let k_total = Int.(+) k m in
    let dc = cert.cDER[k] in
    (forall j. ((is_asm_index cert j /\ Int.(>) j k_total) -> not is_asm_of cert j k_total)) /\
    match dc.rsn, dc.data with
    | Asm, D_none -> is_asm_of cert k_total k_total /\ 
        forall j: int. 
          ((is_asm_index cert j /\ Int.(<) j k_total) -> not is_asm_of cert j k_total)
    | Lin, D_lin_comb weights | Rnd, D_lin_comb weights ->  forall j: int. ((is_asm_index cert j /\ Int.(<) j k_total) ->
          (is_asm_of cert j k_total = 
          exists i: int. 
            ((weights[i] <> 0.0 /\ Int.(<=) j i /\ Int.(<) i k_total) /\ is_asm_of cert j i)))
    | Uns, D_uns indices -> 
        let i1 = indices[0] in
        let l1 = indices[1] in
        let i2 = indices[2] in
        let l2 = indices[3] in
        forall j: int. ((is_asm_index cert j /\ Int.(<) j k_total) ->
          ((is_asm_of cert j k_total) = ((is_asm_of cert j i1 /\ j <> l1) \/ (is_asm_of cert j i2 /\ j <> l2))))
    | Sol, D_none -> 
        forall j: int. 
          ((is_asm_index cert j /\ Int.(<) j k_total) -> not is_asm_of cert j k_total)
    | _, _ -> false
    end  
    
   
  predicate phi_DOM_expanded
  (a1 a2: array real) (b1 b2: real) (eq1 eq2 geq1 geq2 leq1 leq2: bool) =  
  (
    (forall j: int. in_range j n -> a1[j] = 0.0) /\ 
    (if eq1 then b1 <> 0.0 else 
      if geq1 then b1 > 0.0 else 
        if leq1 then b1 < 0.0 else false)
    )
    \/
    (
    (forall j: int. in_range j n -> a1[j] = a2[j]) /\ 
    (if eq2 then eq1 /\ b1 = b2 else 
      if geq2 then geq1 /\ b1 >= b2 else 
        if leq2 then leq1 /\ b1 <= b2 else false)
    )
  
  predicate phi_DOM_constr (c1 c2 : constraint) =
    phi_DOM_expanded
      c1.a c2.a
      c1.b c2.b
      (Int.(=) (sign_to_int c1.s) 0) (Int.(=) (sign_to_int c2.s) 0)
      (Int.(>=) (sign_to_int c1.s) 0) (Int.(>=) (sign_to_int c2.s) 0)
      (Int.(<=) (sign_to_int c1.s) 0) (Int.(<=) (sign_to_int c2.s) 0)
    
  predicate phi_RND (cert: certificate) (a: array real) (eq: bool) =
    (forall j: int. mem j cert.cINT -> is_integer a[j]) /\
    (forall j: int. (in_range j n /\ not mem j cert.cINT) -> a[j] = 0.0) /\
    not eq
  
  predicate phi_DIS (cert: certificate) (ci cj: constraint) =
    (forall k: int. in_range k n -> ci.a[k] = cj.a[k]) /\
    (forall k: int. mem k cert.cINT -> is_integer ci.a[k]) /\
    (forall k: int. (in_range k n /\ not mem k cert.cINT) -> (ci.a[k] = 0.0)) /\
    (is_integer ci.b) /\ (is_integer cj.b) /\
    (ci.s <> Eq /\ cj.s <> Eq /\ ci.s <> cj.s) /\
    (if ci.s = Geq then ci.b = cj.b + 1.0 else ci.b = cj.b - 1.0)
    
  
  predicate phi_DER_k (cert: certificate) (k: int) =
    let k_total = Int.(+) k m in
    let dc = cert.cDER[k] in
    phi_ASM cert k /\
    match dc.rsn, dc.data with
    | Asm, D_none -> true
    
    | Lin, D_lin_comb weights -> 
        let sgn_prod =
        fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        let gen_con : generalized_constraint = get_lin_comb cert weights in 
        (* phi_PRV *)
        (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i k_total) /\
        phi_DOM_expanded gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero (dc.con.s = Eq) all_nonneg (dc.con.s = Geq) all_nonpos (dc.con.s = Leq)    
   
    | Rnd, D_lin_comb weights -> 
        let sgn_prod =
        fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        let gen_con : generalized_constraint = get_lin_comb cert weights in 
        (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i k_total) /\
        phi_RND cert gen_con.lhs all_zero /\
        (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ (* is absurdity *)
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ (*domination part*)
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        )
    | Uns, D_uns indices -> 
        let i1 = indices[0] in
        let l1 = indices[1] in
        let i2 = indices[2] in
        let l2 = indices[3] in
        (Int.(>) k_total i1) /\ (Int.(>) k_total i2) /\ (Int.(>) k_total l1) /\ (Int.(>) k_total l2) /\
        let ci1 = get_constraint cert i1 in
        let cl1 = get_constraint cert l1 in
        let ci2 = get_constraint cert i2 in
        let cl2 = get_constraint cert l2 in
        phi_DOM_constr ci1 dc.con /\ phi_DOM_constr ci2 dc.con /\ phi_DIS cert cl1 cl2
    | Sol, D_none -> 
        if p cert then
          exists sol: array real. mem sol cert.cSOL /\ phi_DOM_constr { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Leq } dc.con
        else
          exists sol: array real. mem sol cert.cSOL /\ phi_DOM_constr { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Geq } dc.con
    | _, _ -> false
    end
  
  predicate phi_DER (cert: certificate) = 
    let d_index = Int.(-) d 1 in
    let cd = get_constraint cert d_index
    in
    (forall k: int. (Int. (<=) 0 k /\ Int. (<) k (Int.(-) d m)) -> phi_DER_k cert k) /\
    if not (r cert) then (phi_DOM_constr cd { a = make n 0.0; b = 1.0; s = Geq }
    /\ (forall j:int. is_asm_index cert j -> not is_asm_of cert j d_index)) else
      (
      (
      (p cert /\ plb cert) -> 
        (
        phi_DOM_constr cd { a = cert.cOBJ.c; b = (l cert); s = Geq } /\
        (forall j:int. is_asm_index cert j -> not is_asm_of cert j d_index)
        )
      ) /\
      (
      (not p cert /\ pub cert) -> 
        (
        phi_DOM_constr cd { a = cert.cOBJ.c; b = (u cert); s = Leq } /\
        (forall j:int. is_asm_index cert j -> not is_asm_of cert j d_index)
        )
      )
      )
  
  predicate phi (cert: certificate) = phi_SOL cert /\ phi_DER cert
  
end


theory Main

  use VIPRCertificate
  use VIPRHelpers
  use VIPRValidity
  use VIPRPredicate
  use array.Array
  use set.Set
  use array.ArrayEq
  use int.Lex2
  use real.Real
  use real.RealInfix
  use real.Abs
  use real.FromInt
  use real.Truncate
  use int.Lex2
  use Sum
  use Init
  use int.Int
  
 
  (******************************** Lemma 1 in paper *******************************************)

  lemma LemmaFEAS: forall cert: certificate. is_cert cert -> (valid_FEAS cert <-> phi_FEAS cert)
 
  (*********************************************************************************************)
  
                               (*helper lemmas*)
  lemma u_matches_ub_when_interval:
    forall cert: certificate, i: interval, ub_val: real.
      not cert.cRTP = Interval i \/ (i.ub = UNum ub_val ->
      u cert = ub_val)
      
  lemma pub_equiv_unum:
    forall cert: certificate.
       not pub cert \/ (exists i: interval.
        cert.cRTP = Interval i /\ i.ub = UNum (u cert))
        
  lemma l_matches_lb_when_interval:
    forall cert: certificate, i: interval, lb_val: real.
      not cert.cRTP = Interval i \/ (i.lb = LNum lb_val ->
      l cert = lb_val)
      
  lemma plb_equiv_lnum:
    forall cert: certificate.
      plb cert ->
      exists i: interval.
        cert.cRTP = Interval i /\ i.lb = LNum (l cert)
        
  lemma r_false_iff_infeasible:
    forall cert: certificate.
      cert.cRTP = Infeasible -> not (r cert)
      
 (*********************************** Lemma 2 in paper *************************************)
 
  lemma LemmaSOL: forall cert: certificate. is_cert cert -> (valid_SOL cert <-> phi_SOL cert)

 (******************************************************************************************)
 
                                    (*helper lemmas*)
  lemma singleton_membership_characterization:
  forall s: set int, x: int.
    mem x s /\
    (forall j: int. j <> x -> not (mem j s)) <->
    s = add x empty
  
  lemma singleton_mem_iff:
  forall x y: int. mem x (add y empty) <-> x = y
  
  lemma is_asm_of_singleton:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    let dc = cert.cDER[k] in
    dc.rsn = Asm -> dc.a_set = add (k + m) empty ->
    forall j: int.
      is_asm_of cert j (k + m) <-> j = k + m
  
  lemma is_asm_index_rsn:
  forall cert: certificate, j: int.
    is_cert cert -> is_asm_index cert j -> cert.cDER[j - m].rsn = Asm
  
  lemma set_extensionality_singleton:
  forall s: set int, x: int.
    (mem x s /\ forall y: int. y <> x -> not mem y s) -> s = add x empty
  
  lemma is_asm_of_iff_mem:
  forall cert: certificate, k j: int.
    is_cert cert -> 0 <= k < d - m -> j >= 0 ->
    is_asm_of cert j (k + m) <-> mem j cert.cDER[k].a_set
  
  lemma a_set_singleton_iff_asm_of_form:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    (cert.cDER[k].a_set = add (k + m) empty <->
     is_asm_of cert (k + m) (k + m) /\
     (forall j: int.
        j <> (k + m) -> not (is_asm_of cert j (k + m))))
  
  lemma asm_data_none:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Asm ->
    cert.cDER[k].data = D_none

 (*********************************Lemma 3 in paper **************************************)

  lemma LemmaASM:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Asm ->
    valid_DER_k cert k <-> phi_DER_k cert k
    
 (****************************************************************************************)

(********************************Lemma 6 in paper ***************************************)
 
  lemma LemmaDOM:
  forall c1 c2: constraint.
    (is_constraint c1 /\ is_constraint c2) ->
    (con_dom_con c1 c2 <-> phi_DOM_constr c1 c2) 
    
 (*******************************************************************************************)
 
                                (*helper lemmas*)
  lemma Lin_Next_Check:
  forall cert:certificate, k:int, weights: array real.
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert /\ cert.cDER[k].rsn = Lin /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) 
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        gen_con_dom_con gen_con dc.con -> phi_DOM_expanded
          gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero
          (dc.con.s = Eq)
          all_nonneg
          (dc.con.s = Geq)
          all_nonpos
          (dc.con.s = Leq)  
          
  
  lemma Lin_intermed_valid_der:
  forall cert:certificate, k:int, weights: array real.
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
    
    is_cert cert  /\ cert.cDER[k].rsn = Lin /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) 
    /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) 
    /\ valid_DER_k cert k -> gen_con_dom_con gen_con dc.con
         
  
  lemma Lin_Next_Check_valid_der_and:
  forall cert:certificate, k:int, weights: array real.
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert /\ cert.cDER[k].rsn = Lin /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) 
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k)
        /\ valid_DER_k cert k -> gen_con_dom_con gen_con dc.con  -> phi_DOM_expanded 
            gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero 
            (dc.con.s = Eq) 
            all_nonneg 
            (dc.con.s = Geq) 
            all_nonpos 
            (dc.con.s = Leq)  
            

  lemma Lin_Next_Check_valid_der_and_DOM:
  forall cert:certificate, k:int, weights: array real.
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert  /\ cert.cDER[k].rsn = Lin
        /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) 
        /\ valid_DER_k cert k -> phi_DOM_expanded
            gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero
            (dc.con.s = Eq)
            all_nonneg
            (dc.con.s = Geq)
            all_nonpos
            (dc.con.s = Leq)     
            
          
  lemma LemmaLINhelp:
  forall cert: certificate, k: int, weights: array real.
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert  -> 0 <= k < d - m -> (cert.cDER[k].rsn = Lin /\ dc.data = D_lin_comb weights) ->
        (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
        valid_DER_k cert k -> (phi_DOM_expanded
          gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero
          (dc.con.s = Eq)
          all_nonneg
          (dc.con.s = Geq)
          all_nonpos
          (dc.con.s = Leq))  
                  
          
  lemma LemmaLIN_oneway:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Lin ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k -> phi_DER_k cert k 
   
                  
  lemma LemmaLin_otherway:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Lin ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    phi_DER_k cert k -> valid_DER_k cert k
   
     
(**************************************** Lemma 7 in paper ****************************************)

  lemma LemmaLin:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Lin ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    phi_DER_k cert k <-> valid_DER_k cert k
     
  (************************************* Lemma 8 in paper ******************************************)   

  lemma LemmaRND_Predicate:
  forall cert: certificate, con: constraint.
    is_cert cert -> phi_RND cert con.a (con.s = Eq) <-> roundable cert con
    
  (*************************************************************************************************)  
    
                                        (*helper lemmas*)
  lemma LemmaRND_C1_NotZero:
  forall cert: certificate, c1: generalized_constraint, c2: constraint, segno: sign.
    is_gen_con_test c1 /\ c1.sgn = Sign segno /\ is_constraint c2 /\ rnd_gen_con_dom_con cert c1 c2 
    /\ not is_absurdity {a = c1.lhs; b = c1.rhs; s = segno} -> not c2.s = Eq 
    
       
  lemma LemmaRND_OneWay_Next_Check:
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
    
        is_cert cert /\ cert.cDER[k].rsn = Rnd /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) 
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        (rnd_gen_con_dom_con cert (get_lin_comb cert weights) dc.con) -> phi_RND cert gen_con.lhs all_zero
        
      
  lemma LemmaRND_OneWay_Big_Check:
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
        
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
    
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert /\ cert.cDER[k].rsn = Rnd /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) 
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        (rnd_gen_con_dom_con cert (get_lin_comb cert weights) dc.con) -> 
        (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ 
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        )
        
        
  lemma LemmaRND_OneWay_All_Together_Unfold:
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert /\ cert.cDER[k].rsn = Rnd
       /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) 
       /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        (rnd_gen_con_dom_con cert (get_lin_comb cert weights) dc.con) -> 
        (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ 
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) /\ phi_RND cert gen_con.lhs all_zero
        
    
  lemma LemmaRND_OneWay_All_Together_Unfold_ALL:
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert /\ cert.cDER[k].rsn = Rnd /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) 
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\ (forall j: int. 0 <= j < k -> valid_DER_k cert j)
        /\ (rnd_gen_con_dom_con cert (get_lin_comb cert weights) dc.con) /\ valid_DER_k cert k -> 
        (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ 
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) /\ phi_RND cert gen_con.lhs all_zero /\ phi_ASM cert k
        
        
  
  lemma LemmaRND_OneWay_All_Together_Unfold_ALL_val:
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in
     
        is_cert cert /\ cert.cDER[k].rsn = Rnd
       /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) 
       /\ (forall j: int. 0 <= j < k -> valid_DER_k cert j) /\valid_DER_k cert k -> 
       (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ 
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) /\ phi_RND cert gen_con.lhs all_zero /\ phi_ASM cert k
        
        
        
  lemma LemmaRND_OneWay_All_Together_Unfold_ALL_val_help:
  forall cert:certificate, k:int, weights: array real.
   
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
        is_cert cert /\ cert.cDER[k].rsn = Rnd
       /\ dc.data = D_lin_comb weights  /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\ 
        (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ 
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  
        (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) /\ phi_RND cert gen_con.lhs all_zero /\ phi_ASM cert k -> phi_DER_k cert k
        
        
    
        
  lemma LemmaRND_OneWay_All_Together_Unfold_ALL_val_help_help:
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    
        is_cert cert /\ cert.cDER[k].rsn = Rnd  /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) 
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) 
        /\ (forall j: int. 0 <= j < k -> valid_DER_k cert j) 
        /\valid_DER_k cert k ->  phi_DER_k cert k
     
        
  
  lemma LemmaRND_OneWay:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Rnd ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k -> phi_DER_k cert k 
        
       
       
  lemma LemmaRND_OtherWay_Next_Check:
  forall cert:certificate, k:int, weights: array real.
    
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert /\ phi_ASM cert k /\ cert.cDER[k].rsn = Rnd  /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m)
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        phi_RND cert gen_con.lhs all_zero /\
        (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ 
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) -> val_ASM cert k
        

        
        
  lemma LemmaRND_OtherWay_Next_Check_Next_Next:
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
        fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
        
            let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
            let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
            let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
            
        let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert /\ phi_ASM cert k /\ cert.cDER[k].rsn = Rnd  /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m)
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        phi_RND cert gen_con.lhs all_zero /\
        (
        (not dc.con.s = Eq /\ 
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ 
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) -> (rnd_gen_con_dom_con cert (get_lin_comb cert weights) dc.con) 
        
        lemma LemmaRND_OtherWay_Next_Check_Next:
        forall cert:certificate, k:int, weights: array real.
        let total_k = Int.(+) k m in
        let dc = cert.cDER[k] in
       
        let sgn_prod =
        fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert /\ phi_ASM cert k /\ cert.cDER[k].rsn = Rnd  /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m)
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        phi_RND cert gen_con.lhs all_zero /\
        (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ (* is absurdity *)
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ (*domination part*)
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  (* added extra case to fix the corner case*)
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) -> (rnd_gen_con_dom_con cert (get_lin_comb cert weights) dc.con) /\ val_ASM cert k
        
         
         
  lemma LemmaRND_OtherWay_Next_Check_Next_extra:
  forall cert:certificate, k:int, weights: array real.
    
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert /\ phi_ASM cert k /\ cert.cDER[k].rsn = Rnd  /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m)
        /\ phi_DER_k cert k -> (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        phi_RND cert gen_con.lhs all_zero /\
        (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ (* is absurdity *)
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ (*domination part*)
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  (* added extra case to fix the corner case*)
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) 
        
        
        
  lemma LemmaRND_OtherWay_Next_Check_Next_extra_extra:
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
        
        is_cert cert /\ cert.cDER[k].rsn = Rnd  /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m)
        /\ phi_DER_k cert k -> (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        phi_RND cert gen_con.lhs all_zero /\
        (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ 
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) /\ phi_ASM cert k
        
        
        
  lemma LemmaRND_OtherWay_Next_Check_Next_phi:
  forall cert:certificate, k:int, weights: array real.
    
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
        
        is_cert cert /\ cert.cDER[k].rsn = Rnd  /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m)
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        phi_DER_k cert k
         -> (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
         (rnd_gen_con_dom_con cert (get_lin_comb cert weights) dc.con) /\ val_ASM cert k
         
         
  
  lemma LemmaRND_OtherWay_Next_Check_Next_Phi_Val:
  forall cert:certificate, k:int, weights: array real.
    
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
        
        is_cert cert /\ cert.cDER[k].rsn = Rnd  /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m)
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        phi_DER_k cert k
         -> valid_DER_k cert k
         
         
  lemma LemmaRND_OtherWay_Next_Check_Next_Phi_Val_Fin:
  forall cert:certificate, k:int, weights: array real.
  
    let dc = cert.cDER[k] in
    
        is_cert cert /\ cert.cDER[k].rsn = Rnd  /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m)
        /\ (forall j: int. 0 <= j < k -> valid_DER_k cert j) -> phi_DER_k cert k -> valid_DER_k cert k
        
 
  lemma LemmaRND_OtherWay:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Rnd ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    phi_DER_k cert k -> valid_DER_k cert k
  
  (************************************** Lemma 9 in paper ********************************************************)  
  
   lemma LemmaRND:
    forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Rnd ->
   (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k <-> phi_DER_k cert k 
         
  (*****************************************************************************************************************)    
    
                                          (*helper lemmas*)
  lemma LemmaDIS_Oneway:
  forall cert: certificate, c1 c2: constraint.
    is_cert cert -> (is_disjunction cert c1 c2 -> phi_DIS cert c1 c2)
    
  lemma LemmaDIS_Otherway:
  forall cert: certificate, c1 c2: constraint.
     is_cert cert -> (phi_DIS cert c1 c2 -> is_disjunction cert c1 c2)

 (*************************************** Lemma 10 in paper *********************************************************) 
  
  lemma LemmaDIS:
  forall cert: certificate, c1 c2: constraint.
    is_cert cert -> (is_disjunction cert c1 c2 <-> phi_DIS cert c1 c2)
 
 (********************************************************************************************************************)   
                                       
                                          (*helper lemmas*)
  lemma LemmaUNS_OneWay_ASM:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Uns ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k -> phi_ASM cert k 
    
    
  lemma LemmaUNS_One_Direction:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Uns ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k -> phi_DER_k cert k   
    
  
  lemma LemmaUNS_Other_Direction:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Uns ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
     phi_DER_k cert k -> valid_DER_k cert k
     
     
 (****************************************** Lemma 11 in paper ********************************************************)
  
  lemma LemmaUNS:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Uns ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k <-> phi_DER_k cert k
    
 (*********************************************************************************************************************)
 
                                          (*helper lemmas*)
    
  lemma LemmaSol_One_Direction_ASM:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Sol ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k -> phi_ASM cert k
    
    
    
  lemma LemmaSol_OneDir_Helper:
  forall cert: certificate, k: int.
  
     let dc = cert.cDER[k] in
     
         is_cert cert -> 0 <= k < d - m ->
         cert.cDER[k].rsn = Sol ->
         (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
         ( (cert.cOBJ.sense = Min ->
         exists sol: array real. mem sol cert.cSOL /\ con_dom_con { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Leq } dc.con) 
         /\ (cert.cOBJ.sense = Max ->
         exists sol: array real. mem sol cert.cSOL /\ con_dom_con { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Geq } dc.con)
         ) ->
         if p cert then
           exists sol: array real. mem sol cert.cSOL /\ phi_DOM_constr { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Leq } dc.con
         else
           exists sol: array real. mem sol cert.cSOL /\ phi_DOM_constr { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Geq } dc.con
       
       
       
  lemma LemmaSol_OneDir_Helper_OtherWay:
  forall cert: certificate, k: int.
  
     let dc = cert.cDER[k] in
     
         is_cert cert -> 0 <= k < d - m ->
         cert.cDER[k].rsn = Sol ->
         (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
         (if p cert then
            exists sol: array real. mem sol cert.cSOL /\ phi_DOM_constr { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Leq } dc.con
          else
            exists sol: array real. mem sol cert.cSOL /\ phi_DOM_constr { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Geq } dc.con)
          -> exists sol: array real. mem sol cert.cSOL /\
          ((cert.cOBJ.sense = Min -> con_dom_con { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Leq } dc.con) /\
          (cert.cOBJ.sense = Max -> con_dom_con { a = cert.cOBJ.c; b = dot cert.cOBJ.c sol; s = Geq } dc.con)) 
    
     
    
  lemma LemmaSOL_valid_OneWay:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Sol ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k -> phi_DER_k cert k

  
  lemma LemmaSOL_valid_OtherWay:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Sol ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
     phi_DER_k cert k -> valid_DER_k cert k
    
 (**************************************************** Lemma 12 in paper ****************************************************)  
  
  lemma LemmaSOL_valid:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Sol ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k <-> phi_DER_k cert k
    
  (**************************************************************************************************************************) 
  
                                                      (*helper lemmas*)
  lemma LemmaDER_Oneway_together:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    (cert.cDER[k].rsn = Sol \/ cert.cDER[k].rsn = Asm \/ cert.cDER[k].rsn = Uns \/ cert.cDER[k].rsn = Lin) ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k -> phi_ASM cert k 
    

  lemma LemmaDER_k_OneWay:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k -> phi_DER_k cert k 
    
    
  lemma LemmaDER_helperASM:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Asm -> valid_DER_k cert k -> phi_DER_k cert k
    
  lemma LemmaDER_helperSol:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Sol -> valid_DER_k cert k -> phi_DER_k cert k
    
  lemma LemmaDER_helperUns:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Uns -> valid_DER_k cert k -> phi_DER_k cert k
    
    
  lemma LemmaDER_helperLin_helper: 
  forall cert: certificate, k: int, weights: array real.
  
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
        
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
    
        is_cert cert  -> 0 <= k < d - m ->
        (cert.cDER[k].rsn = Lin /\ dc.data = D_lin_comb weights) ->
        gen_con_dom_con gen_con dc.con -> (phi_DOM_expanded
            gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero
            (dc.con.s = Eq)
            all_nonneg
            (dc.con.s = Geq)
            all_nonpos
            (dc.con.s = Leq)) 

   
   
  lemma LemmaDER_helperLin_helper_phiASM: 
  forall cert: certificate, k: int, weights: array real.
  
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
    
        is_cert cert  -> 0 <= k < d - m ->
        (cert.cDER[k].rsn = Lin /\ dc.data = D_lin_comb weights) ->
        val_ASM cert k /\ gen_con_dom_con gen_con dc.con -> (phi_DOM_expanded
            gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero
            (dc.con.s = Eq)
            all_nonneg
            (dc.con.s = Geq)
            all_nonpos
            (dc.con.s = Leq)) /\ phi_ASM cert k   
          
    
    
  lemma LemmaDER_helperLin_helper_phiASM_check: 
  forall cert: certificate, k: int, weights: array real.
  
    let dc = cert.cDER[k] in
    let total_k = Int.(+) k m in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
    
        is_cert cert  -> 0 <= k < d - m ->
        (cert.cDER[k].rsn = Lin /\ dc.data = D_lin_comb weights) ->
        val_ASM cert k /\ gen_con_dom_con gen_con dc.con /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) -> (phi_DOM_expanded
            gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero
            (dc.con.s = Eq)
            all_nonneg
            (dc.con.s = Geq)
            all_nonpos
            (dc.con.s = Leq))  /\ phi_ASM cert k /\ (forall j: int. in_range j d /\ weights[j] <> 0.0 -> Int.(<) j total_k)    
              
    
 
  lemma LemmaDER_helperLin_helper_phiASM_check_trans: 
  forall cert: certificate, k: int, weights: array real.
  
    let dc = cert.cDER[k] in
    
        is_cert cert  -> 0 <= k < d - m ->
        (cert.cDER[k].rsn = Lin /\ dc.data = D_lin_comb weights) ->
        valid_DER_k cert k ->  phi_DER_k cert k
        
    
  lemma LemmaDER_helperLin:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Lin -> valid_DER_k cert k -> phi_DER_k cert k
    
  
  lemma is_asm_of_total_k_iff_mem_dc:
  forall cert: certificate,  k j: int.
    0 <= k < d - m ->
    (is_asm_of cert j (Int.(+) k m) <-> mem j cert.cDER[k].a_set)

  lemma mem_a_set_iff_is_asm_of_any:
  forall cert: certificate,  i j: int.
    in_range i d /\ not (in_range i m) ->
    (mem j cert.cDER[Int.(-) i m].a_set <-> is_asm_of cert j i)  
           
 
  
  lemma One_Direction:	
  forall cert: certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    
        is_cert cert /\ cert.cDER[k].rsn = Lin /\ dc.data = D_lin_comb weights 
        /\ (0 <= k < d - m) /\ (forall j. ((is_asm_index cert j /\ Int.(>) j total_k) -> not is_asm_of cert j total_k)) 
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k)  ->
        ( (forall j:int.mem j dc.a_set <-> exists i:int. weights[i] <> 0.0 /\ Int.(<=) m i /\ Int.(<) i total_k /\
         mem j cert.cDER[Int.(-) i m].a_set)
        /\
        (forall i:int. weights[i] <> 0.0 ->
        subset cert.cDER[Int.(-) i m].a_set dc.a_set) ) -> (forall j: int. (is_asm_index cert j /\ Int.(<) j total_k) ->
        (is_asm_of cert j total_k <->  exists i: int. 
       ((weights[i] <> 0.0 /\ Int.(<=) j i /\ Int.(<) i total_k) /\ is_asm_of cert j i)))
            
            
            
  lemma Other_Direction:	
  forall cert: certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    
        is_cert cert /\ cert.cDER[k].rsn = Lin
        /\ dc.data = D_lin_comb weights  /\ (0 <= k < d - m) 
        /\ (forall j. ((is_asm_index cert j /\ Int.(>) j total_k) -> not is_asm_of cert j total_k)) 
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k)  ->
        (forall j: int. (is_asm_index cert j /\ Int.(<) j total_k) ->
        (is_asm_of cert j total_k <->  exists i: int. 
        ((weights[i] <> 0.0 /\ Int.(<=) j i /\ Int.(<) i total_k) /\ is_asm_of cert j i)))  ->  
        ( (forall j:int. mem j dc.a_set <-> exists i:int. weights[i] <> 0.0 /\ Int.(<=) m i /\ Int.(<) i total_k /\
         mem j cert.cDER[Int.(-) i m].a_set)
        /\
        (forall i:int. weights[i] <> 0.0 /\ Int.(<=) m i /\ Int.(<) i total_k ->
        forall j:int. mem j cert.cDER[Int.(-) i m].a_set -> mem j dc.a_set) ) 
    
    
    
  lemma LemmaDER_helperRND_helper:
  forall cert:certificate, k:int, weights: array real.
    
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
    
        is_cert cert /\ cert.cDER[k].rsn = Rnd
        /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        (rnd_gen_con_dom_con cert (get_lin_comb cert weights) dc.con) /\ val_ASM cert k -> (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ 
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) /\ phi_RND cert gen_con.lhs all_zero /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\ phi_ASM cert k
        
        
       
       
  lemma LemmaDER_helperRND_helper_helper:
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
    
        is_cert cert /\ cert.cDER[k].rsn = Rnd
        /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\
        valid_DER_k cert k /\ val_ASM cert k -> (
        (not dc.con.s = Eq /\  
        (
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        \/
        (
        (forall j: int. in_range j n -> gen_con.lhs[j] = dc.con.a[j]) /\ 
        (if dc.con.s = Geq then (all_nonneg /\ (from_int (ceil gen_con.rhs)) >=. dc.con.b) else 
          (all_nonpos /\ (from_int (floor gen_con.rhs)) <=. dc.con.b))
        )
        )
        ) \/  (  
        (forall j: int. in_range j n -> gen_con.lhs[j] = 0.0) /\ 
        (if all_nonneg then gen_con.rhs >. 0.0 else 
          if all_nonpos then gen_con.rhs <. 0.0 else false)
        )
        ) /\ phi_RND cert gen_con.lhs all_zero /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\ phi_ASM cert k
        
  
   
  lemma LemmaDER_helperRnd:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Rnd -> valid_DER_k cert k -> phi_DER_k cert k
    
  lemma LemmaDER_helperRndAltogether:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> (cert.cDER[k].rsn = Asm \/ cert.cDER[k].rsn = Rnd \/ cert.cDER[k].rsn = Uns \/ cert.cDER[k].rsn = Lin \/ cert.cDER[k].rsn = Sol) -> valid_DER_k cert k -> phi_DER_k cert k
    
  lemma LemmaDER_helperRndAltogether_Altogether:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> valid_DER_k cert k -> phi_DER_k cert k
     
    
  lemma LemmaDER_k_OtherWay_Together:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    phi_DER_k cert k -> valid_DER_k cert k

(**************************************************** Corollary 1 in paper **********************************************************) 
  
  lemma LemmaDER_k:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    (forall j: int. 0 <= j < k -> valid_DER_k cert j) ->
    valid_DER_k cert k <-> phi_DER_k cert k 
    
 (***********************************************************************************************************************************) 
 
                                                  (*helper lemmas*)  
   
  lemma LemmaDER_HelperAnother:
  forall cert: certificate.
    is_cert cert -> (forall k: int. in_range k (Int.(-) d m) -> valid_DER_k cert k)  -> (forall k: int. in_range k (Int.(-) d m) -> phi_DER_k cert k)
    
  lemma LemmaDER_forward: forall cert: certificate. is_cert cert -> (valid_DER cert -> phi_DER cert)
  
  lemma LemmaDER_helperASM_OtherDirection:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Asm -> phi_DER_k cert k -> valid_DER_k cert k
    
  lemma LemmaDER_helperSol_OtherDirection:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Sol -> phi_DER_k cert k -> valid_DER_k cert k

  lemma LemmaDER_helperUns_OtherDirection:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Uns -> phi_DER_k cert k -> valid_DER_k cert k
    
  
  
  lemma LemmaDER_helperLin_OtherDir_help:
  forall cert:certificate, k:int, weights: array real.
  
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
    
        is_cert cert  /\ cert.cDER[k].rsn = Lin
        /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) /\
        phi_DOM_expanded
        gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero
        (dc.con.s = Eq)
        all_nonneg
        (dc.con.s = Geq)
        all_nonpos
        (dc.con.s = Leq)  -> (gen_con_dom_con (get_lin_comb cert weights) dc.con)
               
   
   
  lemma LemmaDER_helperLin_OtherDir_help_help:
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
        is_cert cert  /\ cert.cDER[k].rsn = Lin
        /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) /\
        phi_DOM_expanded
        gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero
        (dc.con.s = Eq)
        all_nonneg
        (dc.con.s = Geq)
        all_nonpos
        (dc.con.s = Leq) /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) -> (gen_con_dom_con (get_lin_comb cert weights) dc.con) 
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k)
  
  
  
  lemma LemmaDER_helperLin_OtherDir_help_help_help:
  forall cert:certificate, k:int, weights: array real.
  
     let total_k = Int.(+) k m in
     let dc = cert.cDER[k] in
     let sgn_prod =
     fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
     
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
     let gen_con : generalized_constraint = get_lin_comb cert weights in 
         is_cert cert  /\ cert.cDER[k].rsn = Lin
         /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) /\
         phi_DOM_expanded
         gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero
         (dc.con.s = Eq)
         all_nonneg
         (dc.con.s = Geq)
         all_nonpos
         (dc.con.s = Leq) /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\ phi_ASM cert k 
         -> (gen_con_dom_con (get_lin_comb cert weights) dc.con) 
         /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\ val_ASM cert k
          
          
          
  lemma LemmaDER_helperLin_OtherDir_help_help_help_extra :
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    let sgn_prod =
    fun i -> weights[i] *. (from_int (sign_to_int (get_constraint cert i).s)) in
    
        let all_nonneg : bool = forall i: int. in_range i d -> sgn_prod i >=. 0.0 in
        let all_zero   : bool = forall i: int. in_range i d -> sgn_prod i = 0.0 in
        let all_nonpos : bool = forall i: int. in_range i d -> sgn_prod i <=. 0.0 in
        
    let gen_con : generalized_constraint = get_lin_comb cert weights in 
    
        is_cert cert  /\ cert.cDER[k].rsn = Lin
        /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) /\ phi_DER_k cert k
        ->  phi_DOM_expanded
        gen_con.lhs dc.con.a gen_con.rhs dc.con.b all_zero
        (dc.con.s = Eq)
        all_nonneg
        (dc.con.s = Geq)
        all_nonpos
        (dc.con.s = Leq) /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\ phi_ASM cert k 
          
          
  
  lemma LemmaDER_helperLin_OtherDir_help_help_help_extra_extra :
  forall cert:certificate, k:int, weights: array real.
  
    let total_k = Int.(+) k m in
    let dc = cert.cDER[k] in
    
        is_cert cert  /\ cert.cDER[k].rsn = Lin
        /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) /\ phi_DER_k cert k
        -> (gen_con_dom_con (get_lin_comb cert weights) dc.con) 
        /\ (forall i:int. in_range i d /\ weights[i] <> 0.0 -> Int.(<) i total_k) /\ val_ASM cert k       
          
                 
  
  lemma LemmaDER_helperLin_OtherDir_help_help_help_fin:
  forall cert:certificate, k:int, weights: array real.
  
    let dc = cert.cDER[k] in
    
        is_cert cert  /\ cert.cDER[k].rsn = Lin
        /\ dc.data = D_lin_comb weights /\ (0 <= k < d - m) /\
        phi_DER_k cert k -> valid_DER_k cert k        
  
  
  lemma LemmaDER_helperLin_OtherDirection:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Lin -> phi_DER_k cert k -> valid_DER_k cert k 
    
 
  lemma LemmaRND_OneWay_phi:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    cert.cDER[k].rsn = Rnd ->
    (forall j: int. 0 <= j < k -> phi_DER_k cert j) ->
    phi_DER_k cert k -> valid_DER_k cert k 
 
 
  lemma LemmaDER_k_Phi_oneway:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m ->
    (forall j: int. 0 <= j < k -> phi_DER_k cert j) ->
    phi_DER_k cert k -> valid_DER_k cert k

     
  lemma LemmaDER_helperRnd_OtherDirection:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> cert.cDER[k].rsn = Rnd ->  phi_DER_k cert k -> valid_DER_k cert k 
 
    
  lemma LemmaDER_helperRndAltogether_OtherDirection:
  forall cert: certificate, k:int.
    is_cert cert -> 0 <= k < d - m -> (cert.cDER[k].rsn = Asm \/ cert.cDER[k].rsn = Rnd \/ cert.cDER[k].rsn = Uns \/ cert.cDER[k].rsn = Lin \/ cert.cDER[k].rsn = Sol) -> phi_DER_k cert k -> valid_DER_k cert k  
  
  lemma LemmaDER_helperRnd_OtherDirectionFinal:
  forall cert: certificate, k: int.
    is_cert cert -> 0 <= k < d - m -> phi_DER_k cert k -> valid_DER_k cert k 
    
  lemma LemmaDER_HelperOtherDirection:
  forall cert: certificate.
    is_cert cert -> (forall k: int. in_range k (Int.(-) d m) -> phi_DER_k cert k)  -> (forall k: int. in_range k (Int.(-) d m) -> valid_DER_k cert k)
    
  lemma LemmaDER_OtherWay: forall cert: certificate. is_cert cert -> (phi_DER cert -> valid_DER cert)
  
  (****************************************** Lemma 13 in paper *********************************************************)
  
  lemma LemmaDER: forall cert: certificate. is_cert cert -> (valid_DER cert <-> phi_DER cert)
  
  (*********************************************************************************************************************)
  
                                           (*helper lemmas*)
  lemma MainTheorem_OneWay: forall cert: certificate. is_cert cert -> (valid cert -> phi cert)
  
  lemma MainTheorem_OtherWay: forall cert: certificate. is_cert cert -> (phi cert -> valid cert)  
 
 (*************************************** Equivalence Theorem **********************************************************) 
 
  goal MainTheorem: forall cert: certificate. is_cert cert -> (valid cert <-> phi cert) 
  
 (***********************************************************************************************************************)
     
end
